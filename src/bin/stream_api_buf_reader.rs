use dotenvy::dotenv;
use reqwest::{
    blocking::Client,
    header::{HeaderMap, HeaderValue, ACCEPT, AUTHORIZATION},
};
use serde::Deserialize;
use serde_json::json;
use std::io::{self, BufRead, BufReader, Write};
#[allow(dead_code)]
#[derive(Deserialize, Debug)]
struct ChatCompletionChunk {
    choices: Vec<Choices>,
}

#[allow(dead_code)]
#[derive(Debug, Deserialize)]
struct Choices {
    index: u64,
    delta: Delta,
}

#[allow(dead_code)]
#[derive(Debug, Deserialize)]
struct Delta {
    content: String,
}

fn main() {
    dotenv().expect(".env file not found");
    let openai_api_key =
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not found in .env file");
    let client = Client::new();
    let url = "https://api.openai.com/v1/chat/completions";

    let mut headers = HeaderMap::new();

    headers.insert(
        ACCEPT,
        HeaderValue::from_bytes(b"text/event-stream").unwrap(),
    );
    headers.insert(
        AUTHORIZATION,
        HeaderValue::from_str(&format!("Bearer {}", openai_api_key)).unwrap(),
    );

    let request_body = json!(
        {
            "model": "gpt-4-turbo-preview",
            "messages": [
                {"role": "system", "content": "You are a highly intelligent AI assistant who specializes in creating zkVMs"},
                {"role": "user", "content": "What is a chip with regards to zkVMs?"},
                {"role": "assistant", "content": "In the context of zkVMs (zero-knowledge Virtual Machines), a \"chip\" refers to a specific computational component or gadget within the zkVM architecture. These chips are designed to perform specific functions or computations while preserving the zero-knowledge properties of the system.\n\nHere are a few key points about chips in zkVMs:\n\n1. Functionality: Each chip is responsible for executing a specific task or operation within the zkVM. For example, there might be chips for arithmetic operations, cryptographic functions, memory management, or input/output handling.\n\n2. Zero-knowledge proofs: Chips in zkVMs are designed to generate zero-knowledge proofs for the computations they perform. These proofs allow the zkVM to prove that it executed the specified operations correctly without revealing the underlying data or intermediate results.\n\n3. Composition: zkVMs are typically constructed by composing multiple chips together. The chips are interconnected and work in conjunction to perform the desired computations while maintaining the overall zero-knowledge properties of the system.\n\n4. Efficiency: Chips in zkVMs are optimized for efficient proof generation and verification. They are designed to minimize the computational overhead and proof sizes, enabling faster execution and reduced costs.\n\n5. Modularity: The chip-based architecture of zkVMs allows for modularity and extensibility. New chips can be developed and added to the zkVM to support additional functionalities or optimize existing operations.\n\n6. Examples: Some examples of chips in zkVMs include the ALU (Arithmetic Logic Unit) chip for performing arithmetic and logical operations, the RAM (Random Access Memory) chip for handling memory read/write operations, and the ROM (Read-Only Memory) chip for storing and accessing constant values.\n\nChips in zkVMs play a crucial role in enabling secure and private computation while providing the necessary building blocks for constructing complex zero-knowledge applications. The design and implementation of efficient and secure chips are active areas of research and development in the field of zkVMs."},
                {"role": "user", "content": "If I were to create my own zkVM, what would I need?"},
                {"role": "assistant", "content": "To create your own zkVM, you would need to consider and develop several key components. Here's a high-level overview of what you would need:\n\n1. VM Architecture:\n   - Define the architecture of your zkVM, including the instruction set, memory model, and execution flow.\n   - Determine the types of instructions and operations supported by your zkVM.\n   - Specify the data types, registers, and memory layout.\n\n2. Chip Design:\n   - Identify the necessary computational components or chips required for your zkVM.\n   - Design and implement each chip, defining its functionality, input/output interfaces, and proof generation logic.\n   - Ensure that the chips are optimized for efficient proof generation and verification.\n\n3. Proof System:\n   - Select a suitable zero-knowledge proof system that aligns with your zkVM requirements.\n   - Implement the chosen proof system, including the proof generation and verification algorithms.\n   - Integrate the proof system with the chips and the overall zkVM architecture.\n\n4. Compiler and Assembler:\n   - Develop a compiler that translates high-level programming languages or smart contract languages into the instruction set of your zkVM.\n   - Create an assembler that converts the human-readable assembly language into the binary format understood by your zkVM.\n\n5. Virtual Machine Execution:\n   - Implement the execution engine of your zkVM, which interprets and executes the compiled instructions.\n   - Handle the flow of control, memory management, and state transitions during execution.\n   - Ensure that the execution adheres to the zero-knowledge properties and generates the necessary proofs.\n\n6. Verification and Validation:\n   - Develop tools and mechanisms to verify the correctness and security of your zkVM implementation.\n   - Conduct thorough testing and auditing to identify and fix any vulnerabilities or bugs.\n   - Validate the generated proofs to ensure they are sound and complete.\n\n7. Integration and Ecosystem:\n   - Define the interfaces and APIs for integrating your zkVM with external systems and applications.\n   - Build the necessary tooling, libraries, and documentation to support developers in using your zkVM.\n   - Foster a community and ecosystem around your zkVM to encourage adoption and contributions.\n\nCreating a zkVM from scratch is a complex and challenging endeavor that requires expertise in cryptography, zero-knowledge proofs, compiler design, and system architecture. It involves a significant amount of research, design, and implementation work.\n\nIf you are new to zkVMs, it is recommended to start by studying existing zkVM implementations, such as ZK-SNARK-based systems like Zcash or Mina, or STARK-based systems like StarkNet. Understanding their architectures, design choices, and implementations can provide valuable insights and guidance for creating your own zkVM.\n\nAdditionally, collaborating with experts in the field, engaging with the zkVM community, and leveraging existing libraries and tools can greatly assist in the development process."},
                {"role": "user", "content": "What do I need to study before getting my hands dirty?"},
                {"role": "assistant", "content": "Before diving into the implementation of your own zkVM, it's important to have a solid foundation in several key areas. Here are the main topics you should study and understand:\n\n1. Cryptography:\n   - Familiarize yourself with the fundamentals of cryptography, including symmetric and asymmetric encryption, hash functions, and digital signatures.\n   - Understand the concepts of computational hardness, one-way functions, and trapdoor functions.\n   - Study advanced cryptographic primitives such as commitment schemes, zero-knowledge proofs, and verifiable computation.\n\n2. Zero-Knowledge Proofs:\n   - Dive deep into the theory and concepts behind zero-knowledge proofs, including interactive and non-interactive proofs.\n   - Understand the properties of completeness, soundness, and zero-knowledge.\n   - Study the different types of zero-knowledge proof systems, such as ZK-SNARKs, ZK-STARKs, Bulletproofs, and Polynomial Commitments.\n   - Learn about the underlying mathematical foundations, such as elliptic curve cryptography, pairings, and polynomial arithmetic.\n\n3. Compiler Design and Programming Languages:\n   - Gain knowledge of compiler design principles, including lexical analysis, parsing, semantic analysis, and code generation.\n   - Understand the concepts of abstract syntax trees (ASTs), intermediate representations (IRs), and bytecode generation.\n   - Familiarize yourself with programming language theory, type systems, and formal verification techniques.\n\n4. Virtual Machine Architecture:\n   - Study the principles of virtual machine design, including instruction set architectures (ISAs), memory models, and execution semantics.\n   - Understand the concepts of stack-based and register-based virtual machines.\n   - Explore existing virtual machine architectures, such as the Ethereum Virtual Machine (EVM) or the WebAssembly (Wasm) virtual machine.\n\n5. Cryptographic Engineering:\n   - Learn about the practical aspects of implementing cryptographic primitives and protocols securely.\n   - Understand the best practices for key management, random number generation, and side-channel resistance.\n   - Study the techniques for optimizing cryptographic operations for performance and efficiency.\n\n6. Distributed Systems and Consensus Mechanisms:\n   - Gain knowledge of distributed systems concepts, including fault tolerance, consensus algorithms, and Byzantine fault tolerance (BFT).\n   - Understand the principles of blockchain technology and how zkVMs can be integrated into decentralized systems.\n   - Study the various consensus mechanisms, such as Proof of Work (PoW), Proof of Stake (PoS), and BFT protocols.\n\n7. Formal Verification and Security Analysis:\n   - Learn about formal verification techniques, such as model checking, theorem proving, and symbolic execution.\n   - Understand how to formally specify and verify the correctness and security properties of cryptographic protocols and zkVM components.\n   - Study the techniques for analyzing the security of zero-knowledge proof systems and identifying potential vulnerabilities.\n\nTo gain a deep understanding of these topics, you can refer to academic papers, research publications, and textbooks in the respective fields. Participating in online courses, workshops, and conferences focused on cryptography, zero-knowledge proofs, and virtual machines can also provide valuable insights and learning opportunities.\n\nAdditionally, engaging with the zkVM community, joining forums and discussion groups, and collaborating with experienced practitioners can help you learn from their expertise and stay updated with the latest advancements in the field.\n\nRemember that building a zkVM is a complex endeavor that requires a strong theoretical foundation and practical skills. It's important to allocate sufficient time and effort to study and understand these concepts thoroughly before embarking on the implementation journey."},
                {"role": "user", "content": "Create a roadmap for me to implement my own zkVM from beginner to advanced level having a balance between theory and practical."},
                {"role": "assistant", "content": "Certainly! Here's a roadmap for implementing your own zkVM, balancing theory and practical aspects, from beginner to advanced level:\n\nBeginner Level:\n1. Cryptography Fundamentals:\n   - Study the basics of cryptography, including symmetric and asymmetric encryption, hash functions, and digital signatures.\n   - Implement simple cryptographic primitives like hash functions and encryption algorithms.\n   - Understand the concepts of computational hardness and one-way functions.\n\n2. Introduction to Zero-Knowledge Proofs:\n   - Learn the fundamentals of zero-knowledge proofs, including interactive and non-interactive proofs.\n   - Study the properties of completeness, soundness, and zero-knowledge.\n   - Explore simple examples and intuition behind zero-knowledge proof systems.\n\n3. Programming Languages and Compilers:\n   - Familiarize yourself with a programming language suitable for zkVM development (e.g., Rust, C++, or a functional programming language).\n   - Study the basics of compiler design, including lexical analysis, parsing, and code generation.\n   - Implement a simple compiler for a toy language to understand the compilation process.\n\nIntermediate Level:\n4. Zero-Knowledge Proof Systems:\n   - Dive deeper into specific zero-knowledge proof systems, such as ZK-SNARKs, ZK-STARKs, or Bulletproofs.\n   - Understand the mathematical foundations behind these proof systems, such as elliptic curve cryptography and polynomial commitments.\n   - Implement basic versions of these proof systems and experiment with their properties.\n\n5. Virtual Machine Architecture:\n   - Study the principles of virtual machine design, including instruction set architectures and memory models.\n   - Explore existing virtual machine architectures, such as the Ethereum Virtual Machine (EVM) or WebAssembly (Wasm).\n   - Design and implement a simple virtual machine with a limited instruction set.\n\n6. Cryptographic Engineering:\n   - Learn about secure implementation practices for cryptographic primitives and protocols.\n   - Study techniques for optimizing cryptographic operations for performance and efficiency.\n   - Implement and benchmark different cryptographic algorithms and proof systems.\n\n7. Formal Verification and Security Analysis:\n   - Understand the basics of formal verification techniques, such as model checking and theorem proving.\n   - Learn how to specify and verify the correctness and security properties of cryptographic protocols.\n   - Analyze the security of simple zero-knowledge proof systems and identify potential vulnerabilities.\n\nAdvanced Level:\n8. zkVM Architecture and Chip Design:\n   - Define the architecture of your zkVM, including the instruction set, memory model, and execution flow.\n   - Design and implement the necessary computational components or chips for your zkVM.\n   - Optimize the chips for efficient proof generation and verification.\n\n9. Proof System Integration:\n   - Integrate the chosen zero-knowledge proof system with your zkVM architecture.\n   - Develop the proof generation and verification algorithms for your zkVM.\n   - Optimize the proof system integration for performance and scalability.\n\n10. Compiler and Toolchain Development:\n    - Develop a compiler that translates high-level programming languages into your zkVM's instruction set.\n    - Implement an assembler and linker for your zkVM.\n    - Build debugging and profiling tools to aid in the development process.\n\n11. Verification and Optimization:\n    - Conduct thorough testing and auditing of your zkVM implementation.\n    - Verify the correctness and security of your zkVM using formal verification techniques.\n    - Optimize the performance and efficiency of your zkVM through code analysis and profiling.\n\n12. Integration and Ecosystem Building:\n    - Define the interfaces and APIs for integrating your zkVM with external systems and applications.\n    - Develop libraries, SDKs, and documentation to support developers in using your zkVM.\n    - Engage with the community, gather feedback, and foster adoption of your zkVM.\n\nThroughout this roadmap, it's crucial to balance theoretical understanding with practical implementation. Allocate time for studying research papers, attending conferences, and engaging with the zkVM community to stay updated with the latest advancements and best practices.\n\nRemember that building a zkVM is a significant undertaking, and it's important to break down the roadmap into manageable milestones and iteratively improve and refine your implementation. Collaboration with experienced practitioners and seeking guidance from the community can greatly support your journey."},
                {"role": "user", "content": "Let's start with the first one."},
                {"role": "assistant", "content": "Great! Let's dive into the first step of the roadmap: Cryptography Fundamentals.\n\n1. Study the basics of cryptography:\n   - Begin by understanding the core concepts of cryptography, such as confidentiality, integrity, and authentication.\n   - Learn about symmetric encryption algorithms like AES (Advanced Encryption Standard) and how they work.\n   - Understand asymmetric encryption algorithms, such as RSA (Rivest-Shamir-Adleman) and ECC (Elliptic Curve Cryptography).\n   - Study hash functions, including SHA-256 (Secure Hash Algorithm) and their properties.\n   - Familiarize yourself with digital signatures and their role in ensuring data integrity and authentication.\n\n2. Implement simple cryptographic primitives:\n   - Choose a programming language that you're comfortable with (e.g., Python, Java, or C++).\n   - Implement basic symmetric encryption algorithms like AES or DES (Data Encryption Standard).\n   - Create functions for generating and verifying hash values using SHA-256 or other hash algorithms.\n   - Experiment with generating key pairs and performing encryption and decryption using RSA or ECC.\n   - Implement a simple digital signature scheme using RSA or ECDSA (Elliptic Curve Digital Signature Algorithm).\n\n3. Understand computational hardness and one-way functions:\n   - Study the concept of computational hardness, which forms the basis of cryptographic security.\n   - Learn about one-way functions, which are easy to compute but difficult to invert.\n   - Explore examples of one-way functions, such as the discrete logarithm problem and the factoring problem.\n   - Understand the relationship between computational hardness and the security of cryptographic algorithms.\n\nPractical exercises:\n- Implement a program that encrypts and decrypts a message using AES with a user-provided key.\n- Create a function that calculates the SHA-256 hash of a given input and verifies its integrity.\n- Generate an RSA key pair and use it to encrypt and decrypt a message.\n- Implement a simple digital signature scheme where a message is signed using a private key and verified using the corresponding public key.\n\nResources:\n- \"Cryptography Engineering\" by Niels Ferguson, Bruce Schneier, and Tadayoshi Kohno\n- \"Applied Cryptography\" by Bruce Schneier\n- \"Handbook of Applied Cryptography\" by Alfred J. Menezes, Paul C. van Oorschot, and Scott A. Vanstone\n- Coursera course: \"Cryptography I\" by Dan Boneh (Stanford University)\n- Khan Academy: Cryptography course\n\nBy completing this step, you will gain a solid foundation in cryptography fundamentals, including an understanding of symmetric and asymmetric encryption, hash functions, digital signatures, and the concept of computational hardness. This knowledge will be essential as you progress through the roadmap and delve into more advanced topics related to zkVMs.\n\nRemember to practice implementing the cryptographic primitives and experiment with different algorithms to reinforce your understanding. Don't hesitate to refer to the recommended resources and seek clarification from the community when needed."},
                {"role": "user", "content": "Let's start with the second one."},
                {"role": "assistant", "content": "Great! Let's proceed to the second step of the roadmap: Introduction to Zero-Knowledge Proofs.\n\n1. Learn the fundamentals of zero-knowledge proofs:\n   - Understand the concept of zero-knowledge proofs and their properties: completeness, soundness, and zero-knowledge.\n   - Study the basic idea behind interactive proof systems, where a prover convinces a verifier of a statement without revealing additional information.\n   - Explore non-interactive zero-knowledge proofs (NIZKs) and how they differ from interactive proofs.\n   - Learn about the concept of witness and how it relates to proving statements in zero-knowledge.\n\n2. Study simple examples and intuition behind zero-knowledge proof systems:\n   - Familiarize yourself with classic examples of zero-knowledge proofs, such as the Ali Baba cave example or the graph isomorphism problem.\n   - Understand the intuition behind these examples and how they demonstrate the properties of zero-knowledge proofs.\n   - Explore interactive protocols like the Schnorr protocol or the Fiat-Shamir heuristic for converting interactive proofs into non-interactive ones.\n\n3. Implement basic zero-knowledge proof protocols:\n   - Choose a simple zero-knowledge proof protocol, such as the discrete logarithm equality proof or the Schnorr protocol.\n   - Implement the prover and verifier roles in a programming language of your choice.\n   - Test your implementation by simulating the interaction between the prover and verifier and verifying the properties of completeness, soundness, and zero-knowledge.\n\nPractical exercises:\n- Implement the Schnorr protocol for proving knowledge of a discrete logarithm without revealing the actual value.\n- Create a simple zero-knowledge proof for proving the equality of two discrete logarithms without revealing the logarithms themselves.\n- Explore the Fiat-Shamir heuristic and implement a non-interactive version of a zero-knowledge proof protocol.\n\nResources:\n- \"Proofs, Arguments, and Zero-Knowledge\" by Justin Thaler\n- \"Zero Knowledge Proofs: An illustrated primer\" by Matthew Green\n- \"Efficient Zero-Knowledge Argument for Correctness of a Shuffle\" by Jens Groth and Steve Lu\n- Coursera course: \"Cryptography II\" by Dan Boneh (Stanford University)\n- \"Lectures on Zero-Knowledge Proofs\" by Oded Goldreich\n\nBy completing this step, you will gain a foundational understanding of zero-knowledge proofs, their properties, and the intuition behind them. You will learn about interactive and non-interactive proof systems and implement basic zero-knowledge proof protocols.\n\nAs you progress, you will encounter more advanced zero-knowledge proof systems like zk-SNARKs and zk-STARKs, which build upon these fundamental concepts. Understanding the basics of zero-knowledge proofs is crucial before diving into more complex systems.\n\nRemember to practice implementing the protocols and experiment with different variations to solidify your understanding. Engage with the community, participate in discussions, and seek clarification on any concepts that may be challenging.\n\nKeep in mind that zero-knowledge proofs are a complex and evolving field, so it's important to continuously learn and stay updated with the latest research and advancements."}
            ],
            "stream": true
        }
    );

    let response = client
        .post(url)
        .headers(headers)
        .json(&request_body)
        .send()
        .unwrap();
    let reader = BufReader::new(response);

    let mut buffer = String::new();
    for line in reader.lines() {
        let line = line.unwrap();

        if line.starts_with("data: ") {
            buffer.push_str(&line[6..]); // Extract payload after "data: "
        } else if line.is_empty() {
            // Encountered a complete SSE message
            let chunk_result = serde_json::from_str::<ChatCompletionChunk>(&buffer);
            match chunk_result {
                Ok(chunk) => {
                    print!("{}", chunk.choices[0].delta.content);
                    io::stdout().flush().unwrap();
                }
                Err(_) => {
                    // println!("Error parsing chunk: {:?}", e);
                    continue;
                }
            }
            buffer.clear();
        }
    }
    println!();
}
